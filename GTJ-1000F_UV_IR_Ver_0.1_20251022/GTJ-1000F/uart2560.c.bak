
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <avr/interrupt.h>
#include <avr/io.h>
#include <avr/pgmspace.h>

#include "global.h"
#include "dbg_printf.h"

#include "uart2560.h"
#include "gpio.h"
#include "timer.h"
#include "modbus.h"
#include "mmi.h"
#include "lcd.h"
#include "eeprom.h"


FILE 	*pUart;				//Uart Pointer 정의
UART_VARIABLE	Uart_dbg;		//DBG

U8	Rx0Buf[MAX_USART0_RX_BUFF], Rx0Cnt;

U8	Rx1Buf[2][MAX_USART1_RX_BUFF], Rx1Cnt, Rx1FifoHp, Rx1FifoTp;
U8	Rx1_Packet_Check;
U8	Tx1Buf[MAX_USART1_TX_BUFF], Tx1Cnt;
U8	Tx1BusyFlag, *pTx1Buf;

U8	Rx2_input_Buf[MAX_USART2_RX_BUFF], Rx2_holding_Buf[MAX_USART2_RX_BUFF], Rx2_holding_2nd_Buf[MAX_USART2_RX_BUFF], DET_Rx2Cnt, DET_Rx2Cnt_old, Rx2FifoHp, Rx2FifoTp;
U8	Rx2_write_rx_Buf[MAX_USART2_RX_WRITE_MULTI_BUFF], Rx2_write_tx_Buf[MAX_USART2_RX_WRITE_MULTI_BUFF];
U8	Rx2_Packet_Check;
U8	Tx2Buf[MAX_USART2_TX_BUFF], Tx2Cnt;
U8	Tx2BusyFlag, *pTx2Buf;

U16	Det_Input_Reg_Data[MAX_MODBUS_INPUT_MAX], Det_Holding_Reg_Data[MAX_MODBUS_HOLDING_MAX];
U16	Det_Modbus_Buf[Det_Modbus_Max_Buf];

U8	holding_data_cnt;

void USART2_Packet_Send( U8 *pData, U8 Len );
void Modbus_Det_CRC16(U8 Rdata);
void Det_Reg_Clear(void);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Initialize_UARTBps(void)
{
U16	wBaudRate;
U8	i;

	// _DEBUG_PORT
	Uart_dbg.bReceiveTail = 0;	
	Uart_dbg.bReceiveHead = 0;

	UCSR0A = ( 1 << U2X0 );  /* Double Speed */
	UCSR0B = ( 1 << RXCIE0 ) | ( 1 << RXEN0  ) | ( 1 << TXEN0 );	//RX INT,RX 인에이블,TX 가능
	UCSR0C = ( 1 << USBS0  ) | ( 1 << UCSZ01 ) | ( 1 << UCSZ00 );	//UCSR0C Write Register Set,비동기,none패리티,8비트,1스톱비트

	wBaudRate = (U16)(( ATMEGA_XTAL / ( 8 * (U32)_DBG_BAUD_SPEED ) ) - 1);	// 통신속도 계산식
	UBRR0H = (U8)((wBaudRate >> 8 ) & 0xFF );
	UBRR0L = (U8)((wBaudRate & 0xFF));

	// _MODBUS_PORT
	MODBUS_DIR_RX();
	UCSR1A = ( 1 << U2X1 ); /* Double Speed */
	UCSR1B = ( 1 << RXCIE1 ) | ( 1 << RXEN1  ) | ( 1 << TXCIE1 ) | ( 1 << TXEN1 );
	UCSR1C = ( 1 << USBS1  ) | ( 1 << UCSZ11 ) | ( 1 << UCSZ10 );

	wBaudRate = (U16)(( ATMEGA_XTAL / ( 8 * (U32)_MODBUS_BAUD_SPEED ) ) - 1);	// 통신속도 계산식
	UBRR1H = (U8)((wBaudRate >> 8 ) & 0xFF );
	UBRR1L = (U8)((wBaudRate & 0xFF));

	RS485_DIR_RX();
	// _RS485_PORT
	UCSR2A = ( 1 << U2X2 ); /* Double Speed */
	UCSR2B = ( 1 << RXCIE2 ) | ( 1 << RXEN2  ) | ( 1 << TXCIE2 ) | ( 1 << TXEN2 );						// Rx Interrupt enable
	UCSR2C = ( 1 << USBS2  ) | ( 1 << UCSZ21 ) | ( 1 << UCSZ20 );

	wBaudRate = (U16)(( ATMEGA_XTAL / ( 8 * (U32)_RS485_BAUD_SPEED ) ) - 1);	// 통신속도 계산식
	UBRR2H = (U8)((wBaudRate >> 8 ) & 0xFF );
	UBRR2L = (U8)((wBaudRate & 0xFF));
	
	Tx1BusyFlag = 0;
	
	for(i = 0; i < Det_Modbus_Max_Buf; i++){
		Det_Modbus_Buf[i] = 0;
	}
	Det_Modbus_Buf[Det_Reg_Status_Old] = 0xff;
	holding_data_cnt = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ISR(USART0_RX_vect)		//DBG
{
	Uart_dbg.bReceiveBuff[ Uart_dbg.bReceiveHead ] = UDR0;				// 16바이트 링버퍼에 수신값 저장
	Uart_dbg.bReceiveHead = ( Uart_dbg.bReceiveHead + 1 ) % _MAX_UART_BUFF;		// 16바이트 링버퍼에 수신값 증가, 모듈러 연산자
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ISR(USART1_RX_vect)
{
	U8	bStatus, bData;
	
	bStatus = UCSR1A;
	bData = UDR1;
	
	if ( !( bStatus & ( FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN )) )
	{
	        if( Rx1Cnt >= MAX_USART1_RX_BUFF )
	        {
			Rx1Cnt = 0;
		}
			
		Rx1Buf[Rx1FifoHp&1][Rx1Cnt] = bData;
		Rx1Cnt++;
		
		Rx1_Packet_Check = 0x83; // 4ms
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ISR(USART1_TX_vect)
{
	if( !Tx1Cnt ){
		MODBUS_DIR_RX();
		Tx1BusyFlag = 0;
	}
	else {
		UDR1 = *pTx1Buf++;
		Tx1Cnt--;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ISR(USART2_RX_vect) 	//AIH Interface
{
U8	bStatus, bData;
	
	bStatus = UCSR2A;
	bData = UDR2;
	
	if ( !( bStatus & ( FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN )) )
	{
		if(DET_Rx2Cnt+1 >= _MAX_UART_DET_BUFF)
		{
			DET_Rx2Cnt=0;
		}
		
		if(Det_Modbus_Buf[Det_Reg_Status] == usart2_input_tx_complete)
		{
			Rx2_input_Buf[DET_Rx2Cnt] = bData;
		}
		else if(Det_Modbus_Buf[Det_Reg_Status] == usart2_holding_tx_complete)
		{
			Rx2_holding_Buf[DET_Rx2Cnt] = bData;
		}
		else if(Det_Modbus_Buf[Det_Reg_Status] == usart2_write_s_tx_complete)
		{
			Rx2_write_rx_Buf[DET_Rx2Cnt] = bData;
		}
		else if(Det_Modbus_Buf[Det_Reg_Status] == usart2_write_m_1st_tx_complete)
		{
			Rx2_write_rx_Buf[DET_Rx2Cnt] = bData;
		}
		else if(Det_Modbus_Buf[Det_Reg_Status] == usart2_write_m_2nd_tx_complete)
		{
			Rx2_write_rx_Buf[DET_Rx2Cnt] = bData;
		}
		
		DET_Rx2Cnt++;
		
		Rx2_Packet_Check = 0x83; // 4ms
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ISR(USART2_TX_vect)
{
	if( !Tx2Cnt )
	{
		RS485_DIR_RX();
		Tx2BusyFlag = 0;
	}
	else
	{
		UDR2 = *pTx2Buf++;
		Tx2Cnt--;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Putchar_U0(char ch, FILE *stream)	 	//DBG
{
	if( ch == '\n' )
	{
		Putchar_U0('\r', stream );         //커서를 처음으로 옮긴다.
	}

	while( !(UCSR0A & ( 1 << UDRE0 )) );   //Uart Tx Buff Not Empty
	UDR0 = ch;                             //Uart Tx Buff Transmitts

	return 0 ;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void USART1_Rx_Packet_Check( void )
{
	if( Rx1_Packet_Check & 0x80 )
	{
		if( Rx1_Packet_Check == 0x80 )
		{
			Rx1_Packet_Check = 0;

			if( Rx1Cnt > 7 )
			{
				if( Rx1Buf[Rx1FifoHp&1][0] == Dvc_Address )
				{
					sTimerTick[TMR_MODBUS_TIMEOUT] = 0x8000+99; // 100ms
					sTimerFlag[TMR_MODBUS_TIMEOUT] = 0;
					Rx1FifoHp++;
				}
				else
				{
					sTimerTick[TMR_MODBUS_TIMEOUT] = 0;
					sTimerFlag[TMR_MODBUS_TIMEOUT] = 0;
				}
			}
			Rx1Cnt = 0;
		}
		else
		{
			Rx1_Packet_Check--;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void USART1_Rx_Handler( void )
{
	U8		bHp, bTp;
	
	bHp = Rx1FifoHp & 1;
	bTp = Rx1FifoTp & 1;
	
	if( bHp != bTp ){
		Rx1FifoTp++;
		MODBUS_Packet_Decoder( &Rx1Buf[bTp][0] );
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void USART1_Packet_Send( U8 *pData, U8 Len )
{
	U16		i;
	
	sTimerTick[TMR_MODBUS_TIMEOUT] = 0;
	
	if( sTimerFlag[TMR_MODBUS_TIMEOUT] ){
		sTimerFlag[TMR_MODBUS_TIMEOUT] = 0;
	}
	else {
		if( !Tx1BusyFlag ){
			MODBUS_DIR_TX();
			for( i=0; i<Len; i++ ){
				Tx1Buf[i] = *(pData+i);
			}
			pTx1Buf = Tx1Buf;
			Tx1Cnt = Len-1;
			UDR1 = *pTx1Buf++;
			Tx1BusyFlag = 1;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void USART2_Rx_Packet_Check(void)
{
	if( Rx2_Packet_Check & 0x80 )
	{
		if( Rx2_Packet_Check == 0x80 )
		{
			Rx2_Packet_Check = 0;
			
			switch(Det_Modbus_Buf[Det_Reg_Status]){
				case usart2_input_tx_complete:
					if(DET_Rx2Cnt == (INPUT_REG_MAX_CNT*2)+5){
						Det_Modbus_Buf[Det_Reg_Status] = usart2_input_rx_complete;
					}
					break;
				case usart2_holding_tx_complete:
					if(DET_Rx2Cnt == (HOLDING_REG_MAX_CNT*2)+5){
						Det_Modbus_Buf[Det_Reg_Status] = usart2_holding_rx_complete;
					}
					break;
				case usart2_write_s_tx_complete:
					if(DET_Rx2Cnt == MAX_USART2_RX_WRITE_BUFF)
					{
						Det_Write_Err();
						Det_Modbus_Buf[Det_Reg_Status] = usart2_write_s_rx_complete;
					}
					break;
				case usart2_write_m_1st_tx_complete:
					if(DET_Rx2Cnt == MAX_USART2_RX_WRITE_BUFF)
					{
						Det_Write_Err();
						Det_Modbus_Buf[Det_Reg_Status] = usart2_write_m_1st_rx_complete;
					}
					break;
				case usart2_write_m_2nd_tx_complete:
					if(DET_Rx2Cnt == MAX_USART2_RX_WRITE_BUFF)
					{
						Det_Write_Err();
						Det_Modbus_Buf[Det_Reg_Status] = usart2_write_m_2nd_rx_complete;
					}
					break;
			}
			DET_Rx2Cnt = 0;
		}
		else
		{
			Rx2_Packet_Check--;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void USART2_RX_Handler(void)
{
U8	bData[256];
U16	index = 0;
U16	wCRC;
U8	i;

	if(Det_Modbus_Buf[Det_Reg_Status_Old] != Det_Modbus_Buf[Det_Reg_Status]){
		switch(Det_Modbus_Buf[Det_Reg_Status]){
			case usart2_input_ready:
				//TP12_AIC_T();
				//DPRINT("Input\n");
				bData[index++] = Det_Address;
				bData[index++] = MTX_FUNCODE_INPUT;
				bData[index++] = 0;
				bData[index++] = 0;
				bData[index++] = 0;
				bData[index++] = INPUT_REG_MAX_CNT;
				
				wCRC = CRC16( &bData[0], 6 );
				bData[index++] = wCRC & 255;
				bData[index++] = wCRC >> 8 & 255;
				
				USART2_Packet_Send( bData, index );
	
				Det_Modbus_Buf[Det_Reg_Status] = usart2_input_tx_complete;
				sTimerTick[TMR_DET_TIMEOUT] = USART2_TIMEOUT_CNT;
				sTimerFlag[TMR_DET_TIMEOUT] = 0;
				//DPRINT1("INPUT Timeout = %x\n", sTimerTick[TMR_DET_TIMEOUT]);
				break;
			case usart2_holding_ready:
				TP12_AIC_T();
				//DPRINT1("Holding = %d\n", holding_data_cnt);
				bData[index++] = Det_Address;
				bData[index++] = MTX_FUNCODE_HOLDING;
				bData[index++] = 0;
				bData[index++] = HOLDING_REG_MAX_CNT * holding_data_cnt;
				bData[index++] = 0;
				bData[index++] = HOLDING_REG_MAX_CNT;
	
				wCRC = CRC16( &bData[0], 6 );
				bData[index++] = wCRC & 255;
				bData[index++] = wCRC >> 8 & 255;
				
				USART2_Packet_Send( bData, index );
	
				Det_Modbus_Buf[Det_Reg_Status] = usart2_holding_tx_complete;
				sTimerTick[TMR_DET_TIMEOUT] = USART2_TIMEOUT_CNT;
				sTimerFlag[TMR_DET_TIMEOUT] = 0;
				//DPRINT("Holding 1 Timeout\n");
				break;
			case usart2_write_s_ready:
				if(Det_Modbus_Buf[Det_Write_Register_Flag] == 1){
					//DPRINT1("Single Write = %d\n", Det_Modbus_Buf[Det_Write_Register_Flag]);
					Rx2_write_tx_Buf[index++] = Det_Address;
					Rx2_write_tx_Buf[index++] = MTX_FUNCODE_WRITE_SINGLE;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Addr] >> 8 & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Addr] & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Data] >> 8 & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Data] & 255;
					
					wCRC = CRC16( &Rx2_write_tx_Buf[0], index );
					Rx2_write_tx_Buf[index++] = wCRC & 255;
					Rx2_write_tx_Buf[index++] = wCRC >> 8 & 255;
					
					USART2_Packet_Send( Rx2_write_tx_Buf, index );
			
					Det_Modbus_Buf[Det_Reg_Status] = usart2_write_s_tx_complete;
					sTimerTick[TMR_DET_TIMEOUT] = USART2_TIMEOUT_CNT;
					sTimerFlag[TMR_DET_TIMEOUT] = 0;
					
					Det_Modbus_Buf[Det_Write_Register_Flag] = 0;
					//DPRINT("Single Write Timeout\n");
				}
				else{
					Det_Modbus_Buf[Det_Reg_Status] = usart2_write_s_complete_delay;
					sTimerFlag[TMR_MODBUS_DELAY] = 1;
					//DPRINT("Single No data\n");
				}
				break;
			case usart2_write_m_1st_ready:
				if(Det_Modbus_Buf[Det_Write_Register_Flag] == 2){
					//DPRINT1("Multi Write 1 = %d\n", Det_Modbus_Buf[Det_Write_Register_Flag]);
					Det_Modbus_Buf[Det_Write_Register_Addr] = DET_EEP_EVT_IR430_DRIFT_T_MAX_L;
					Det_Modbus_Buf[Det_Write_Register_Data] = 100;
					
					Rx2_write_tx_Buf[index++] = Det_Address;
					Rx2_write_tx_Buf[index++] = MTX_FUNCODE_WRITE_MULTIPLE;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Addr] >> 8 & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Addr] & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Data] >> 8 & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Data] & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Data] * 2;
					
					for(i = 0; i < Det_Modbus_Buf[Det_Write_Register_Data]; i++)
					{
						Rx2_write_tx_Buf[index++] = write_register_data_arry[i] >> 8 & 255;
						Rx2_write_tx_Buf[index++] = write_register_data_arry[i] & 255;
					}
					
					wCRC = CRC16( &Rx2_write_tx_Buf[0], index );
					
					Rx2_write_tx_Buf[index++] = wCRC & 255;
					Rx2_write_tx_Buf[index++] = wCRC >> 8 & 255;
					
					USART2_Packet_Send( Rx2_write_tx_Buf, index );
			
					Det_Modbus_Buf[Det_Reg_Status] = usart2_write_m_1st_tx_complete;
					sTimerTick[TMR_DET_TIMEOUT] = USART2_TIMEOUT_CNT + 999;
					sTimerFlag[TMR_DET_TIMEOUT] = 0;
					//DPRINT("Multi Write TX C\n");
				}
				else{
					Det_Modbus_Buf[Det_Reg_Status] = usart2_write_m_1st_complete_delay;
					sTimerFlag[TMR_MODBUS_DELAY] = 1;
					//DPRINT("Multi 1 No data\n");
				}
				break;
			case usart2_write_m_2nd_ready:
				if(Det_Modbus_Buf[Det_Write_Register_Flag] == 2){
					//DPRINT1("Multi Write 2 = %d\n", Det_Modbus_Buf[Det_Write_Register_Flag]);
					Det_Modbus_Buf[Det_Write_Register_Addr] = DET_EEP_EVT_IR530_1S_PTOP_BF_2S;
					Det_Modbus_Buf[Det_Write_Register_Data] = 30;
					
					Rx2_write_tx_Buf[index++] = Det_Address;
					Rx2_write_tx_Buf[index++] = MTX_FUNCODE_WRITE_MULTIPLE;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Addr] >> 8 & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Addr] & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Data] >> 8 & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Data] & 255;
					Rx2_write_tx_Buf[index++] = Det_Modbus_Buf[Det_Write_Register_Data] * 2;
					
					for(i = 0; i < Det_Modbus_Buf[Det_Write_Register_Data]; i++)
					{
						Rx2_write_tx_Buf[index++] = write_register_data_arry[i] >> 8 & 255;
						Rx2_write_tx_Buf[index++] = write_register_data_arry[i] & 255;
					}
					
					wCRC = CRC16( &Rx2_write_tx_Buf[0], index );
					
					Rx2_write_tx_Buf[index++] = wCRC & 255;
					Rx2_write_tx_Buf[index++] = wCRC >> 8 & 255;
					
					USART2_Packet_Send( Rx2_write_tx_Buf, index );
			
					Det_Modbus_Buf[Det_Reg_Status] = usart2_write_m_2nd_tx_complete;
					sTimerTick[TMR_DET_TIMEOUT] = USART2_TIMEOUT_CNT + 999;
					sTimerFlag[TMR_DET_TIMEOUT] = 0;
					
					Det_Modbus_Buf[Det_Write_Register_Flag] = 0;
					//DPRINT("Multi Write Timeout\n");
				}
				else{
					Det_Modbus_Buf[Det_Reg_Status] = usart2_write_m_2nd_complete_delay;
					sTimerFlag[TMR_MODBUS_DELAY] = 1;
					Det_Modbus_Buf[Det_Write_Register_Flag] = 0;
					//DPRINT("Multi 2 No data\n");
				}
				break;
		}
		Det_Modbus_Buf[Det_Reg_Status_Old] = Det_Modbus_Buf[Det_Reg_Status];
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void USART2_Packet_Send( U8 *pData, U8 Len )
{
U16 i;
	if( !Tx2BusyFlag ){
		RS485_DIR_TX();
		for( i=0; i<Len; i++ ){
			Tx2Buf[i] = *(pData+i);
		}
		pTx2Buf = Tx2Buf;
		Tx2Cnt = Len-1;
		UDR2 = *pTx2Buf++;
		Tx2BusyFlag = 1;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void modbus_mapping(void)
{
U8	i;
	
	//DPRINT1("WRF C 3 = %d\n",Det_Modbus_Buf[Det_Reg_Status] );
	switch(Det_Modbus_Buf[Det_Reg_Status]){
		case usart2_input_rx_complete:
			for(i = 0; i < INPUT_REG_MAX_CNT + 1; i++)
			{
				Det_Input_Reg_Data[i] = (Rx2_input_Buf[ (i * 2) + 3] << 8) | Rx2_input_Buf[ (i * 2) + 4];
			}
			Det_Modbus_Buf[Det_Reg_Status] = usart2_input_complete_delay;
			sTimerFlag[TMR_MODBUS_DELAY] = 1;
			//TP12_AIC_T();
			break;
		case usart2_holding_rx_complete:
			for(i = 0; i < HOLDING_REG_MAX_CNT; i++)
			{
				Det_Holding_Reg_Data[i + (HOLDING_REG_MAX_CNT * holding_data_cnt)] = (Rx2_holding_Buf[ (i * 2) + 3] << 8) | Rx2_holding_Buf[ (i * 2) + 4];
			}
			if(holding_data_cnt == 0){
				Det_Modbus_Buf[Det_Reg_Status] = usart2_input_complete_delay;
				holding_data_cnt = 1;
			}
			else{
				Det_Modbus_Buf[Det_Reg_Status] = usart2_holding_complete_delay;
				holding_data_cnt = 0;
			}
			TP12_AIC_T();
			sTimerFlag[TMR_MODBUS_DELAY] = 1;
			break;
		case usart2_write_s_rx_complete:
			Det_Modbus_Buf[Det_Reg_Status] = usart2_write_s_complete_delay;
			Det_Modbus_Buf[Det_Write_Register_Set_Flag] = 0;
			sTimerFlag[TMR_MODBUS_DELAY] = 1;
			break;
		case usart2_write_m_1st_rx_complete:
			Det_Modbus_Buf[Det_Reg_Status] = usart2_write_m_1st_complete_delay;
			sTimerFlag[TMR_MODBUS_DELAY] = 1;
			break;
		case usart2_write_m_2nd_rx_complete:
			Det_Modbus_Buf[Det_Reg_Status] = usart2_write_m_2nd_complete_delay;
			Det_Modbus_Buf[Det_Write_Register_Set_Flag] = 0;
			sTimerFlag[TMR_MODBUS_DELAY] = 1;
			break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Det_Reg_Clear(void)
{
	memset( Det_Input_Reg_Data, 0, sizeof(Det_Input_Reg_Data) );
	memset( Det_Holding_Reg_Data, 0, sizeof(Det_Holding_Reg_Data) );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Det_Comm_Err(void)
{
	if( (Det_Modbus_Buf[Det_Reg_Status] == usart2_input_tx_complete) | (Det_Modbus_Buf[Det_Reg_Status] == usart2_holding_tx_complete)
		| (Det_Modbus_Buf[Det_Reg_Status] == usart2_write_s_tx_complete) | (Det_Modbus_Buf[Det_Reg_Status] == usart2_write_m_1st_tx_complete) | (Det_Modbus_Buf[Det_Reg_Status] == usart2_write_m_2nd_tx_complete) ){
		if(!Det_Modbus_Buf[Det_Comm_Err_Flag])
		{
			DPRINT("Det Comm ERR\n");
			if(DET_Rx2Cnt == DET_Rx2Cnt_old)
			{
				Det_Modbus_Buf[Det_Comm_Err_Cnt]++;
				if(Det_Modbus_Buf[Det_Comm_Err_Cnt] > DET_COMM_ERR_MAX)
				{
					Det_Modbus_Buf[Det_Comm_Err_Cnt] = DET_COMM_ERR_MAX;
					Det_Modbus_Buf[Det_Comm_Err_Flag] = 1;
					DET_Rx2Cnt = 0;
					LCD_Clear_Line_All();
					Det_Reg_Clear();
				}
			}
			DET_Rx2Cnt_old = DET_Rx2Cnt;
		}
	}
	else{
		Det_Modbus_Buf[Det_Comm_Err_Cnt] = 0;
		Det_Modbus_Buf[Det_Comm_Err_Flag] = 0;
	}
}

void Det_Write_Err(void)
{
U8	i, flag = 0;
	if( (Det_Modbus_Buf[Det_Reg_Status] == usart2_write_s_tx_complete) | (Det_Modbus_Buf[Det_Reg_Status] == usart2_write_m_1st_tx_complete) | (Det_Modbus_Buf[Det_Reg_Status] == usart2_write_m_2nd_tx_complete) )
	{
		for(i = 0; i < MAX_USART2_RX_WRITE_BUFF - 2; i++){
			if(Rx2_write_rx_Buf[i] != Rx2_write_tx_Buf[i]){
				flag++;
			}
			//DPRINT2("RX = %d, TX = %d\n", Rx2_write_rx_Buf[i], Rx2_write_tx_Buf[i]);
		}
		
		if(flag != 0){
			Det_Modbus_Buf[Det_Write_Err_Flag] = 2;

		}
		else{
			Det_Modbus_Buf[Det_Write_Err_Flag] = 1;
		}
		//DPRINT1("DWEF = %d\n", Det_Modbus_Buf[Det_Write_Err_Flag]);
	}
}

void Det_Write_Single_Func(U16 addr, S16 data)
{
	Det_Modbus_Buf[Det_Write_Register_Addr] = addr;
	Det_Modbus_Buf[Det_Write_Register_Data] = data;
	Det_Modbus_Buf[Det_Write_Register_Flag] = 1;
	//DPRINT("Write Single Set\n");
}

void Det_Write_Multi_Func(void)
{
	Det_Modbus_Buf[Det_Write_Register_Flag] = 2;
	//DPRINT("Write Multi Set\n");
}

